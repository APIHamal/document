#####mongodb与副本集相关的命令
1)db.isMaster()
  该命令用来查看当前副本位于整个集群中的相关角色信息以及打印副本集群的相关信息
2)rs.status()
  该命令用来查看当前副本集的信息以及副本集中成员的相关信息

#####mongodb副本集设置(注意:副本集搭建成功后会自动同步用户信息[因此在任意节点创建用户并赋权即可])
1)mongodb中副本集相关角色的分类以及区别
                  -------  [primary]   副本集中的主节点(相当于领导者节点)
                 |-------  [secondary] 跟随着节点(相当于follower节点)
 --------------  |-------  [arbiter]   仲裁者节点只参与副本集的投票不参与数据复制
| MongoDB Role |_|-------  [priority0] 参与数据复制及投票(与secondary类似)但是永远不会成为primary(主节点)
 --------------  |             |
				 |             |------ [hidden]  隐藏节点拥有priority0的属性但是对[客户端不可见]
                 |             |------ [delayed] 延迟节点拥有priority0属性但是复制数据存在延迟
                 |-------  [vote0]     仅执行副本集数据复制不参与集群的投票操作(同zk服务中的observer节点类似)

#####mongodb副本集搭建过程
1)配置文件中配置相关属性
  replication:
   replSetName: "mongodb_cluster"
   #该属性用来配置当前副本集的名称(副本集的集群中该名称必须相同否则无法启动集群数据)
  security:
   keyFile: /usr/local/mongodb/conf/mongo.key
   #该属性用来配置副本集群内部之间通信时使用key认证的认证文件(该文件在多个副本集中必须
   相同并且权限必须是400[chmod 400 mongo.key]权限否则mongodb无法正常启动并且非400权限启
   动时会发生报错)
2)生成副本集之间通信时使用的keyFile文件(理论上该文件的内容可以是任意的值[通常设置随机字符串即可])
  但是一定要注意文件的权限必须是400权限(非400权限mongodb启动会报错并无法启动成功)
  ###通常使用openssl命令生成一个随机的字符串
  例如:openssl rand -base64 256 > mongo.key
       该命令表示使用生成一个256位长度并且使用base64进行编码的[随机字符串]并将内容
	   输出到mongo.key文件中
  ###将keyFile文件移动到mongod.conf(mongodb配置文件)中security.keyFile中指定的位置
3)启动mongodb服务程序
  例如:mongod -f conf/mongod.conf
       依次在副本集中执行该命令启动mongodb服务器成功启动后副本集会通过raft算法进行选举
	   完成后续的流程
4)初始化副本集配置(连接副本集中的任意一个节点即可)
  rs.initiate( {
     _id : "mongodb_cluster",
     members: [
  	  {_id:0,host:"192.168.168.168:27017"},
  	  {_id:1,host:"192.168.168.169:27017"},
  	  {_id:2,host:"192.168.168.170:27017"}
     ]
  })
  #相关参数说明
  _id:"mongodb_cluster"设置当前副本集的名称(该名称与mongod.conf中的replication.replSetName属性必须相同)
  members设置当前副本集中的成员信息
  ##_id  用于设置副本节点的标示
  ##host 用于设置副本集节点的IP地址

#####mongodb中的固定集合(固定集合行为类似FIFO队列)
1)mongodb中的固定集合典型的应用场景就是oplog(操作日志副本集同步就是使用oplog作为临时的命令存储的数据结构)
  固定集合应该显示的被创建
  #db.createCollection(collName,{capped:true,size:byteSize,max:docSize})
   capped 表示当前创建的集合对象是一个[固定集合]
   size   表示当前固定集合占用存储空间的上限(例如4096表示最高只允许分配4kb的空间)
   max    表示当前固定集合中可存储文档数量的上限(max:10表示最多只能存储10个元素)
  #固定集合的特定
  (1)固定集合采用顺序写操作(不允许删除元素)因此写性能非常高
  (2)固定集合中不允许删除元素(FIFO随着元素的写入会自动的淘汰最先入队的元素)
  (3)固定集合中更新元素有很高的限制(更新后文档占用空间必须与更新前文档占用空间相同
     文档占用空间相同可更新否则不允许更新文档并且会报错提示)
  (4)固定集合不支持分片操作(mongodb分片架构中不允许使用固定集合)

#####mongodb副本集数据同步原理
1)oplog作用与原理(同redis中的复制积压缓冲区作用类似用于存储写入命令区别是oplog中命令全是[幂等性命令])
  副本集环境搭建完成后primary对于所有的写命令均会输出一份到oplog集合中(oplog集合本身是一个固定集合存
  入oplog集合有助于其余节点进行增量的同步数据)oplog本身是一个固定集合并且具备FIFO的特性(集合空间被
  耗尽后最先进入集合的命令会被自动的移除)节点初始化同步完成后会拉取oplog中的数据进行重放操作因此当拉取
  完成后整个集群的数据处于一致的状态(此后只要增量同步oplog中的数据即可)
2)初始化同步
  副本集启动后除primary|arbiter|vote0三种角色的节点外其余节点均需要与primary节点通信进行数据复制
  初始状态下不存在任何的数据因此会执行一次全量复制操作(因此在集群压力较大时不应该增加副本集做同步
  操作会消耗大量的资源)并且在进行全量复制的同时拉取oplog中的数据(这样做的目的是为了防止数据断裂的发
  生:当primary写入的速度大于节点的复制速度会造成最早进入oplog集合的命令被移除[FIFO特性]如果是按照
  全量复制完成后再拉取oplog集合这时会发生数据丢失的情况[也称数据断裂即部分命令被删除了]发生该情况时
  则整个复制流程失败因此当执行全量复制的同时拉取oplog集合即不会发生上述数据断裂的情况)
  ###首先执行全量复制跟随者节点重放数据
  ###全量复制完成后重放当前以及拉取到的oplog集合数据
  ###增量同步primary节点的oplog数据(拉取完成后整个副本集数据处于一致的状态)
3)oplog的幂等性(幂等性十分的重要)
  oplog为了实现命令的幂等性会重新命令例如将自增命令直接重写成赋值命令
  例如:
  db.coll.update({title:'mongodb教程'},{$inc:{count:10}})
  #该命令是将所有title为mongodb教程的文档中的count值增加10首先该命令是个非幂等性的命令如果复制过程中发生意外
   导致复制失败(例如瞬时网络问题)但是一段时间后又恢复正常的状态此时该命令可能会被执行多次导致发生数据
   不一致的问题(非幂等命令多次执行会产生不一样的结果)因此mongodb会重写该命令
  例如:
  db.coll.update({title:'mongodb教程'},{$set:{count:100}})
  #mongodb会将命令重写为上述的形式(幂等命令)该命令无论执行多少次最终的结果都是相同并不会产生不一致的数据结果

 